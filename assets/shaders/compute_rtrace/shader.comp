#version 450 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in; /* This shader is run per pixel. */
layout(rgba32f, binding = 0) uniform image2D imageOut;


void intersection(
    in vec3  origin, 
    in vec3  dir, 
    in vec3  sphereCenter, 
    in float sphereRadius,
    out vec2 roots
) {
    float a, b, c;
    vec3 omc = origin - sphereCenter;

    a = dot(dir, dir);
    b = dot(dir, omc);
    c = dot(omc, omc) - sphereRadius*sphereRadius;
    
    c = abs(sqrt(b * b - a * c)); /* 4 gets canceled out. */
    a = 1.0f / a;

    b *= a;
    c *= a;


    roots = vec2(b - c, b + c);
    return;
}



void main()
{
    const vec3  sphereOrigin = vec3(0.0f, 0.0f, -1.0f);
	const vec3  cameraOrigin = vec3(0.0f, 0.0f, -5.0f);
    const float sphereRadius = 2.0f;
    const vec3  sphereColor  = vec3(1.0f, 0.0f,  1.0f);
    const vec2  ViewFrustum  = vec2(-10.0f, -10.0f);


    ivec2       texel        = ivec2(gl_GlobalInvocationID.xy);
    ivec2       wdims        = imageSize(imageOut);
    vec4        value        = vec4(0.0, 0.0, 0.0, 1.0);



    vec2  texef = vec2(texel);
    vec2  dims  = vec2(wdims);

    texef = (texef * 2 - dims) / dims;
    texef *= dims.x / dims.y;
    vec3  rayOrigin = vec3(texef * ViewFrustum, 0.0f);
	vec3  rayDir    = vec3(0.0f, 0.0f, -1.0f);
    vec2  roots     = vec2(0.0f, 0.0f);
    bvec2 nnan;
    
    intersection(rayOrigin, rayDir, sphereOrigin, sphereRadius, roots);
    nnan = isnan(roots); nnan.x = !nnan.x; nnan.y = !nnan.y;
    value.xyz = sphereColor * vec3(vec2(nnan), 0.0f);
    
    
    imageStore(imageOut, texel, value);	
}


// value.xy = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
// value.xy /= vec2(wdims);